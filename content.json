{"meta":{"title":"Silent_Eの桜荘","subtitle":null,"description":"喵帕斯!","author":"Silent_E","url":""},"pages":[{"title":"","date":"2020-02-21T09:03:25.057Z","updated":"2020-02-21T09:03:25.057Z","comments":true,"path":"games/index.html","permalink":"/games/index.html","excerpt":"","text":""},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-02-26T09:23:07.214Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のSilent_E] 与&nbsp; Silent_E&nbsp; 对话中... bot_ui_ini() 或许更详细的我？","keywords":"关于"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-02-21T06:19:45.432Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-02-20T13:08:20.147Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-02-13T17:11:22.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-02-13T17:11:22.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-02-13T17:11:22.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-02-13T17:11:22.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-02-26T10:30:33.436Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-02-23T13:50:33.943Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-02-13T17:11:22.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-02-13T17:11:22.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-02-13T17:11:22.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"【转载】镜面边缘的人","slug":"镜面边缘的人","date":"2020-02-23T12:57:07.000Z","updated":"2020-02-23T13:21:57.476Z","comments":true,"path":"镜面边缘的人/","link":"","permalink":"/镜面边缘的人/","excerpt":"","text":"转载自百度贴吧，我对这段文字太有感触了。 是啊，我们都是行走在镜面边缘的人，仰望着遥不可及的未来，却未把握真实的现在。 谨以此，献给我短暂的OI生涯，献给所有Oier，献给所有以梦为马的人！ 理想在哪里？未来在哪里？ 当初我们或犹豫或坚决地走上了学科竞赛这条路，在现实的大门面前。 我们有着这样那样的理由，或者是兴趣，或者是保送。 但是在我们踏上这条路的时候，几乎就没有了退路。 今天是河南省信息学竞赛省队选拔赛。 vani发来短信说，他挂了，求安慰。 我无言。大概去年秋天，我败在联赛赛场上的时候，也说过类似的话。 包括去年夏天在烟台，去年五月在北京。 学科竞赛是一条难以预料的路。就算你有超神的实力，也会考出2B的成绩。 虽然高考也是，但我想高考还不及学科竞赛这样难以捉摸。 数学二试，只有4道大题，一道大题40或50分，基本拿不到过程分，要么就是做出来，要么就是做不出来。高考一道题，不会让你从一本A类栽倒二本；而数学一道题，可能就是保送和二等的区别。 信息国赛，每试5个小时3道题，一道100分；更忐忑的是，数学你写错一个字可能还会蒙混过关，但在信息竞赛里，打错一个字，很可能100分的程序就是零蛋。因为失误丢掉一百多分的例子，比比皆是。 如果只是这样，也就算了；如果只是付出不一定得到回报，也就算了。 竞赛的苦不在出成绩的那一刻；你要付出的，也远远不是考砸的几滴泪水。 没有战友。没有同伴。一群同是天涯沦落人的OIer，在网上结识，互相鼓励，一同努力。 而当你掐掉本机电源回到现实的时候，是鄙夷的老师，是遥远的同学，是叹息的家长，是堆积成山的小卷子，是不堪入目的月考分。 高考是主流，竞赛是非主流，而学信息的更是非主流中的非主流。 “学那有什么用？高考又不考。” 看到高考生捧着一张张流光溢彩的月考卷子，只有一声叹息。 看到数学（物理/化学/生物）老师赞许地看看那些上课看数学（物理/化学/生物）竞赛的尖子，只有一声叹息。 看到其他学科竞赛的同学三五成群激烈地讨论，还是只有一声叹息。 自习课，班主任抽走来不及藏的《算法设计》，面无表情地“你下课来一趟”。 考试后，同学小心翼翼地发给你一张满是红叉的卷子。 遇到难题不会做时，一个人苦思冥想，看着QQ里的灰色头像，不知该求助谁。 因为条件所限，只能在晚自习回家后编码到半夜，第二天头晕脑胀地再去学勒夏特列原理。 最难过的是父母一次次地无奈询问，“现在文化课还能跟得上么？不行就别学了……” …… 大家都说，高考是千军万马过独木桥，不容易。 可是又有几个“大家”知道，竞赛是一个人摸黑走路，盲人骑瞎马，半夜临深池？ 在无数个孤独清冷的深夜，无数次羡慕已经安然入梦的同学们。 我们都是行走在镜面边缘的人。 低下头看到的，是半个迷茫的自己，和半个不见底的深渊。 到哪里，会不会跌倒，是到终点还是滑进深渊，都不知道。 唯一确定的是，自己只有一个人。 世界上有天才，这无可否认； 但天才不是我，想到终点，只有靠努力。 所以从高一开始就过上高三的生活，所以无奈地跟社团活动集体活动等等等等说再见。 所以从高一开始就习惯在半夜以后入睡，习惯一个人在寒冷的夜里机械地敲动手指，而双脚因为长时间坐姿已经冰凉。 戒掉游戏。戒掉小说。戒掉感情。戒掉漫画。戒掉泡吧。最终甚至戒掉文化课。 这就是OIer的选择。 只剩下孤身一人的卑微，和遍体鳞伤的坚强。 刚刚vani说，他卡线进队了。 心里一块石头总算落了地。 他又说，去年联赛满分的xmz神牛，没有进队。 想起去年在烟台，我邻桌的湖北女生失声痛哭。 想起在长沙认识的另一位湖北神牛短信里，无奈的“挂了”。 想起连挂六次决然高考的小胖。 想起去年五月的我，去年八月的我，去年十一月的我。 选择了做一名OIer，就选择了要孤独，要坚强，要百折不挠，要在跌倒之后擦干血和泪，继续在无尽的夜里走下去。 六月份省选，八月份全国赛，能走多远，我不知道。 已经想好要做两手准备，如果兵败吉林，我还可以回来搞保送生考试。 可是如果保送生考试再输了呢？ …… 可是如果自主招生考试再输了呢？ ………… 可是如果高考还是输了呢？ ………………………… 镜面的边缘，滑一步就是万丈深渊。 为了兴趣或者为了保送——总之我们赌上了我们的高中。 记得有一次，一个家长讽刺我说，“计算机竞赛有什么了不起，数学物理拿了保送才叫真本事。” 更多的家长讽刺说，“竞赛拿保送有什么了不起，高考才是真本事。” 本事你妹。没什么了不起，您来试试？或者您家公子来试试？ 可是冷静下来，这就是竞赛生，以至OIer的现状。 不成功没人看得起。成功了还是没人看得起。 老师看不起，家长看不起，有些同学也看不起。 总之就是没人看得起。 你可以说，这是潇洒，逍遥，特立独行。 但心里清楚，这是孤独，卑微，前途暗淡。 虽然这也让我们多了一份磨砺，多了一份坚强。 物理竞赛吧有人说，PhO makes a man man。 我想不管哪一门竞赛都是一样。 选择竞赛，选择OI，既是痛苦，亦是福祉。 5月生物联赛。6月信息省选。8月信息全国赛。9月物理化学联赛。10月数学联赛。 Bless all.","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"杂文","slug":"杂文","permalink":"/tags/杂文/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"期望DP小结","slug":"期望DP小结","date":"2019-12-07T13:18:01.000Z","updated":"2020-02-23T12:58:50.466Z","comments":true,"path":"期望DP小结/","link":"","permalink":"/期望DP小结/","excerpt":"","text":"资源分享 26 个比较概率大小的问题 数论小白都能看懂的数学期望讲解 概念$PS$：不需要知道太多概念，能拿来用就行了。 定义样本（$\\omega$）：一次随机试验产生的一个结果。样本空间（$\\Omega$）：一个随机试验的所有可能的结果的全体，即$\\Omega={\\omega}$。事件（$A$）：某一类结果，即$A\\subset\\Omega$。基本事件（$s$）：各个互斥的事件即为基本事件。 我们借助样本空间S来定义概率。样本空间是基本事件的集合。 概率论公理样本空间$S$的概率分布$Pr{}$是一个从$S$的事件到实数的映射，它满足以下公理： 非负性：对于任意事件$A$，$Pr{A}\\geqslant 0$。 正则性：$Pr{S}=1$。 可列可加性：对于两个互斥事件$A$与$B$，有$Pr{A\\cup B}=Pr{A}+Pr{B}$。更一般地，对于任意有限或无限事件序列$A_1,A_2,…,$若其两两互斥，则有： $$Pr{\\bigcup_iA_i}=\\sum Pr{A_i}$$ 期望 简单理解，期望的意义就是概率的加权平均数。 假设某随机试验$X$共有$n$种互斥的事件可能发生，其中第$i$个事件发生的概率为$P_i$，价值为$X_i$，则这个随机试验的期望是$E(X)=\\sum P_iX_i$。 期望也可以从频率的角度来理解，我们知道如果不断重复某个随机试验，某个事件发生的频率会趋近于其概率，而将发生过所有事件的价值取平均值，这个值就会趋近于这个随机试验的期望。 期望的线性性质$$E(X+Y)=E(X)+E(Y)….(1)$$ $$E(aX)=aE(X)…………..(2)$$ $$E(XY)=E(X)E(Y)……….(3)$$ 证明如下 (1)式:$$\\begin{align}E(X+Y) =&amp; \\sum_{i,j}(X_i+Y_j)P_iQ_j\\=&amp; \\sum_{i, j} X_{i} P_{i} Q_{j}+\\sum_{i, j} Y_{j} P_{i} Q_{j}\\=&amp; \\sum_{i} X_{i} P_{i} \\sum_{j} Q_{j}+\\sum_{j} Y_{j} Q_{j} \\sum_{i} P_{i}\\=&amp; \\sum_{i} X_{i} P_{i}+\\sum_{i} Y_{j} Q_{j}\\=&amp; E(X)+E(Y)\\end{align}$$(2)式:$$\\begin{align}E(aX) =&amp; \\sum_iaX_iP_i \\=&amp; a\\sum_iX_iP_i \\=&amp; aE(X)\\end{align}$$(3)式:$$\\begin{align}E(XY)=&amp; \\sum_i\\sum_jX_iY_jP_iQ_j \\=&amp;(\\sum_iX_iP_i)(\\sum_jY_jQ_j) \\=&amp;E(X)E(Y)\\end{align}$$用数学归纳法可推广到多个。 期望DP定义所求结果为某事件的期望的动态规划。 实际上这类动态规划并不是一个新的类型，它都是在原有的动态规划的基础上，将所求的值改成了概率和期望的相关值，换句话说，这类问题的难度其实还是在动态规划的原型上，概率和期望只是表象。 现在大多数期望题就是手动找公式或者$DP$推出即可，只要处理好边界，然后写好方程，就行了。与常规的求解不同，数学期望经常逆向推出，但不全是。它的代码量很短，但思维难度明显较高。 比如数学期望的$f[x]$一般表示到了$x$这一状态还差多少，最后答案是$f[0]$。 总之，该推公式的还是推，该在图上跑的还是在图上跑，只是注意状态的设计。 练手题目入门：过河少见的连续型随机变量题。 最坏情况下，过一条河需要 $3\\frac{L}{v}$ 的时间；最好的情况下，过一条河需要 $\\frac{L}{v}$ 的时间，又因为船的位置随机，所以过河时间线性分布，于是期望取个平均值 $2\\frac{L}{v}$ 就行了。 掷骰子考虑集合中选取一个不同于已选的新数的概率，所以可以设计$DP$方程：$f[i]$表示取了$i$种数后还需取的期望值。 取了$i$种数，当前取的是新数的概率是$\\frac{n-i}{n}$，当前取的是集合中出现过的数的概率是$\\frac{i}{n}$。所以可得到$DP$转移方程$f[i]=\\frac{n-i}{n}f[i+1]+\\frac{i}{n}f[i]+1$。 进一步化简，得$f[i]=f[i+1]+\\frac{n}{n-i}$。 所以$f[0]=\\sum_{i=1}^n\\frac{n}{i}$。 换教室夭寿啦，NOIP考期望啦。 容易对每节课的选择划分阶段，根据期望的线性性质，可以相加得到总期望。 设$f[i][j][0/1]$表示前$i$节课提交了$j$次申请，当前是否申请时的期望最小体力值。那么只会从$i-1$转移过来。 方程见代码。（懒癌晚期。。。） #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;algorithm&gt; #define db double #define Re register const int N = 2000 + 5; const db INF = 1e18; using std :: max; using std :: min; inline int read() { int f = 1, x = 0; char ch; do { ch = getchar(); if (ch == &#39;-&#39;) f = -1; } while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;); do {x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - &#39;0&#39;; ch = getchar(); } while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;); return f * x; } inline void init(), dp(), ouot(); signed main() { init(), dp(), ouot(); } inline void hand_in() { freopen(&quot;classroom.in&quot;, &quot;r&quot;, stdin); freopen(&quot;classroom.out&quot;, &quot;w&quot;, stdout); } int n, m, v, e, c[N], d[N]; db k[N], f[N][N][2], dis[305][305], ans = INF; inline void init() { hand_in(); n = read(), m = read(), v = read(), e = read(); for (Re int i = 1;i &lt;= n; ++i) c[i] = read(); for (Re int i = 1;i &lt;= n; ++i) d[i] = read(); for (Re int i = 1;i &lt;= n; ++i) scanf(&quot;%lf&quot;, k + i); for (Re int i = 1;i &lt;= v; ++i) { for (Re int j = 1;j &lt;= v; ++j) { if (i != j) dis[i][j] = INF; } } for (Re int i = 1, x, y, w;i &lt;= e; ++i) { x = read(), y = read(), w = read(); dis[x][y] = min(dis[x][y], (db)w); dis[y][x] = dis[x][y]; } for (Re int s = 1;s &lt;= v; ++s) { for (Re int i = 1;i &lt;= v; ++i) { for (Re int j = 1;j &lt;= v; ++j) { dis[i][j] = min(dis[i][j], dis[i][s] + dis[s][j]); } } } } inline void dp() { for (Re int i = 0;i &lt;= n; ++i) { for (Re int j = 0;j &lt;= m; ++j) { f[i][j][0] = f[i][j][1] = INF; } } f[1][0][0] = f[1][1][1] = 0; for (Re int i = 2, lim;i &lt;= n; ++i) { lim = min(i, m); f[i][0][0] = f[i - 1][0][0] + dis[c[i - 1]][c[i]]; for (Re int j = 1;j &lt;= lim; ++j) { f[i][j][0] = min(f[i][j][0], f[i - 1][j][0] + dis[c[i - 1]][c[i]]); f[i][j][0] = min(f[i][j][0], f[i - 1][j][1] + k[i - 1] * dis[d[i - 1]][c[i]] + (1.0 - k[i - 1]) * dis[c[i - 1]][c[i]]); f[i][j][1] = min(f[i][j][1], f[i - 1][j - 1][0] + k[i] * dis[c[i - 1]][d[i]] + (1.0 - k[i]) * dis[c[i - 1]][c[i]]); f[i][j][1] = min(f[i][j][1], f[i - 1][j - 1][1] + k[i] * (k[i - 1] * dis[d[i - 1]][d[i]] + (1.0 - k[i - 1]) * dis[c[i - 1]][d[i]]) + (1.0 - k[i]) * (k[i - 1] * dis[d[i - 1]][c[i]] + (1.0 - k[i - 1]) * dis[c[i - 1]][c[i]])); } } } inline void ouot() { for (int i = 0;i &lt;= m; ++i) ans = min(ans, min(f[n][i][0], f[n][i][1])); printf(&quot;%.2lf&quot;, ans); exit(0); } 进阶：亚瑟王思考后，转化成$ans=\\sum dp[i]*d[i]$，其中,$dp[i]$表示第$i$张卡在$r$轮中打出的概率。 考虑如何计算$dp[i]$。 由于每一轮打出一张卡后，该轮结束，所以每张卡在$r$轮中被打出的概率与在它前面有多少张卡被打出有关。 设$f[i][j]$表示在$r$轮中，前$i$张卡被打出了$j$张的概率，在此情况下，第$i+1$张牌在$r$轮中有$(1-p[i+1])^{r-j}$的概率未被打出，再用$1$减去，就得到了打出s的概率。所以枚举$k$得到：$dp[i]=\\sum f[i-1][k]*(1-(1-p[i])^{r-k})$。 现在考虑如何计算$f[i][j]$。 递推。当前的第$i$张卡选或不选。选：$f[i][j]+=f[i-1][j-1](1-(1-p[i])^{r-j+1})$。$(j\\neq 0)$不选：$f[i][j]+=f[i-1][j]((1-p[i])^{r-j})$。$(i\\neq j)$ 边界：$f[1][1]=dp[1]=1-(1-p[1])^r$$f[1][0]=(1-p[1])^r$ 本题得到解决。（注意精度！） #include&lt;cmath&gt; #include&lt;ctime&gt; #include&lt;queue&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #define debug() puts(&quot;FBI WARNING!&quot;) #define ll long long using namespace std; const int MAX = 220 + 5; const int P = 1e5 + 7; inline int read(){ int f = 1, x = 0;char ch; do { ch = getchar(); if (ch == &#39;-&#39;) f = -1; } while (ch &lt; &#39;0&#39;||ch&gt;&#39;9&#39;); do {x = x*10+ch-&#39;0&#39;; ch = getchar(); } while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;); return f * x; } int t, n, r; double p[MAX], d[MAX], ans, f[MAX][MAX], dp[MAX], pw[MAX][MAX]; inline double mi(double a, int b) { double res = 1.0; while (b) { if (b &amp; 1) { res *= a; } a *= a; b &gt;&gt;= 1; } return res; } int main(){ t = read(); while (t--) { memset(dp, 0, sizeof (dp)); memset(f, 0, sizeof (f)); ans = 0; n = read(), r = read(); for (int i = 1;i &lt;= n; ++i) scanf(&quot;%lf %lf&quot;, &amp;p[i], &amp;d[i]); f[1][1] = dp[1] = 1.0 - mi(1.0 - p[1], r); f[1][0] = mi(1.0 - p[1], r); for (int i = 2;i &lt;= n; ++i) { for (int j = 0;j &lt;= min(i, r); ++j) { if (j) { f[i][j] += f[i - 1][j - 1] * (1.0 - mi(1.0 - p[i], r - j + 1)); } if (i != j) { f[i][j] += f[i - 1][j] * mi(1.0 - p[i], r - j); } } } for (int i = 2;i &lt;= n; ++i) { for (int k = 0;k &lt;= min(i - 1, r); ++k) { dp[i] += f[i - 1][k] * (1.0 - mi(1.0 - p[i], r - k)); } } for (int i = 1;i &lt;= n; ++i) { ans += dp[i] * d[i]; } printf(&quot;%.10lf\\n&quot;, ans); } return 0; } 概率充电器$WA$了无数遍。。。有一个坑人的小细节。。。 思考后，可转换成$ans=\\sum (1-res[i])$。其中，$res$表示节点$i$未被充电的概率。 强制把这棵树转化为有根树，我们可以发现，对与任意非根节点，它能否被点亮取决于它的子节点以及它的父亲。想到树形$DP$。 我们设$f[i]$，$g[i]$分别表示$i$不被它的子节点点亮的概率，$i$不被它父亲点亮的概率。 所以$res[i]=f[i]\\times g[i]$。 现在思考如何求$f[i]$。 第一遍$dfs$遍历时，直接 $f[i]=(1-p[i])\\times \\prod_{son\\in i}\\lgroup1-(1-f[son]\\times val(i,son))\\rgroup$，无需过多的解释。 由于根节点无父节点，所以$g[root]=1$，即$res[root]=f[root]$现在，思考如何求非根节点的$g[i]$。 做到这里，我先前有个抽风的想法，以为直接可以$g[v]=ans[u]+(1-ans[u])\\times (1-val(u,v))$($v$是$u$的子节点)，当$WA$到怀疑人生时才想到这是错误的。。。想想为什么？ 请注意，$g[i]$的状态定义是：$i$不被它父亲点亮的概率，所以不管子节点鸟事。。。即默认为$v$不带电，所以我们需要把$ans[u]$除去先前乘进$f[i]$中的$v$子树中不带电的概率。 即$P=\\frac{g[u]\\times f[u]}{1-(1-f[v]\\times val(u,v))}$，$g[v]=P+(1-P)\\times (1-val(u,v))$。 本题得到$O(n)$解决。 #include&lt;cmath&gt; #include&lt;ctime&gt; #include&lt;queue&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; const int MAX = 500000 + 5; inline int read(){ int f = 1, x = 0;char ch; do { ch = getchar(); if (ch == &#39;-&#39;) f = -1; } while (ch &lt; &#39;0&#39;||ch&gt;&#39;9&#39;); do {x = x*10+ch-&#39;0&#39;; ch = getchar(); } while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;); return f * x; } int n, m; double p[MAX], ans[MAX], res, f[MAX], g[MAX], h[MAX]; struct sakura { int to, nxt; double p; }sak[MAX &lt;&lt; 1]; int head[MAX], cnt; inline void add(int x, int y, double p) { ++cnt; sak[cnt].to = y, sak[cnt].nxt = head[x], sak[cnt].p = p, head[x] = cnt; } inline void dfs_1(int u, int fa) { f[u] = 1.0 - p[u]; g[u] = 1.0; for (int i = head[u];i;i = sak[i].nxt) { int v = sak[i].to; double ps = sak[i].p; if (v == fa) continue; dfs_1(v, u); // f[u] *= (1.0 - (1.0 - f[v]) * ps); f[u] *= (f[v] + (1.0 - f[v]) * (1.0 - ps)); } } inline void dfs_2(int u, int fa) { for (int i = head[u];i;i = sak[i].nxt) { int v = sak[i].to; double ps = sak[i].p; if (v == fa) continue; double h; if (f[v] + (1.0 - f[v]) * (1.0 - ps)) { h = (g[u] * f[u]) / (f[v] + (1.0 - f[v]) * (1.0 - ps)); } else h = 0.0; g[v] = h + (1.0 - h) * (1.0 - ps); dfs_2(v, u); } } int main(){ n = read(); for (int i = 1;i &lt; n; ++i) { int a = read(), b = read(); double c; scanf(&quot;%lf&quot;, &amp;c); add(a, b, 0.01 * c); add(b, a, 0.01 * c); } for (int i = 1;i &lt;= n; ++i) scanf(&quot;%lf&quot;, &amp;p[i]), p[i] *= 0.01; dfs_1(1, 0); dfs_2(1, 0); g[1] = 1; for (int i = 1;i &lt;= n; ++i) { ans[i] = f[i] * g[i]; } for (int i = 1;i &lt;= n; ++i) res += (1.0 - ans[i]); printf(&quot;%.6lf&quot;, res); return 0; } 奖励关刚拿到这题。 ？？？ $Woc$！怎么做？ 好在看了眼数据范围，，，哦，，，状压套个期望啊。。。 倒着找，就行了。 #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #define Re register using namespace std; const int MAX = 100 + 5; inline int read(){ int f = 1, x = 0;char ch; do { ch = getchar(); if (ch == &#39;-&#39;) f = -1; } while (ch &lt; &#39;0&#39;||ch&gt;&#39;9&#39;); do {x = x*10+ch-&#39;0&#39;; ch = getchar(); } while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;); return f * x; } int k, n, miko[MAX]; double f[MAX][1 &lt;&lt; 15], a[MAX], ans; int main(){ k = read(), n = read(); for (int i = 1;i &lt;= n; ++i) { scanf(&quot;%lf&quot;, &amp;a[i]); int x; while (x = read()) { miko[i] = miko[i] | (1 &lt;&lt; (x - 1)); } } for (int i = k;i &gt;= 1; --i) { for (int j = 0;j &lt; (1 &lt;&lt; n); ++j) { for (int l = 1;l &lt;= n; ++l) { if ((j &amp; miko[l]) == miko[l]) { f[i][j] += max(f[i + 1][j | (1 &lt;&lt; (l - 1))] + a[l], f[i + 1][j]); } else { f[i][j] += f[i + 1][j]; } } f[i][j] /= n; } } printf(&quot;%.6lf\\n&quot;, f[1][0]); } 迷失游乐园马马马？？？ 是树的情况貌似和前面的看脸充电器差不多？？？搞一下。 我们设从一个节点$i$的子节点传上来的期望值为$f[i]$，从父节点传下来的期望值为$g[i]$，令$u$为$v$的父节点，所以可得$f[u]=\\frac{\\sum f[v]+w(u,v)}{son[u]}$，然后以此更新$g[v]$：$g[v]=w(u,v)+\\frac{f[u]\\times son[u]-w(u,v)-f[v]+g[u]}{son[u]-1+1}$。 具体含义就$YY$一下吧，懒癌晚期。。。 $About$ $1h$ $later…$ $have$ $50$ $Pt$ $…$ 好了，现在处理环的情况！ $Another$ $1h$ $later…$ $Woc$！环怎么处理啊！ 偷偷瞟了眼题解，稍微有了点思路。 首先，从基环树环上节点的子节点传上来的更新是一样的，这点没有任何怀疑。主要是$g[i]$的更新。 对于环上的点，我们默认为它们的父亲即为环上与它相邻的两个节点。所以它分别有一半的概率走到与它相邻的两个节点上。 所以，我们强迫它先顺序走一遍，再逆序走一遍，最后两个期望值相加再除以$2$，即可得到$g[x]$。 $g[i]=\\sum P_j\\times (w(j-1,j)+f[j]\\times \\frac{son[j]}{son[j]+1})$ 其中,$P_j$表示为走到环上节点$j$的概率。 然后环上的$g[x]$更新了，就可以对于环上每个节点所形成的子树进行遍历更新了。 $g[v]=w(u,v)+\\frac{fat[u]\\times g[u]+f[u]\\times son[u]-f[v]-w(u,v)}{fat[u]+son[u]-1}$ 其中，$fat[x]$表示$x$父节点的个数。 找环简单说一下，直接开栈记录就行了。 再吐槽一下，这题我改了一下午加一晚上，还是红彤彤的，后来一气之下全员$double$，，，然后，，，它就过了。。。 这题必须代码。 #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #define Re register #define C(x) circle[x] #define T(x) tag[x] const int MAX = 100000 + 5; inline int read(){ int f = 1, x = 0;char ch; do { ch = getchar(); if (ch == &#39;-&#39;) f = -1; } while (ch &lt; &#39;0&#39;||ch&gt;&#39;9&#39;); do {x = x*10+ch-&#39;0&#39;; ch = getchar(); } while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;); return f * x; } struct sakura { int to, nxt, w; }sak[MAX &lt;&lt; 1]; int head[MAX], cnt; double f[MAX], ans, g[MAX], res, son[MAX], P, dis[25][25], fat[MAX]; int stack[MAX], top, vis[MAX], circle[MAX], count, num, st, nex[MAX], pre[MAX], tag[MAX]; bool find = 0; inline void add(int x, int y, int w) { ++cnt; sak[cnt].to = y, sak[cnt].nxt = head[x], sak[cnt].w = w, head[x] = cnt; } /* 找环 */ inline void pre_dfs_1(int u, int fa) { if (find) return; vis[u] = 1, stack[++top] = u; for (int i = head[u];i;i = sak[i].nxt) { int v = sak[i].to; if (v == fa) continue; if (vis[v]) { while (stack[top] != v) { circle[++count] = stack[top--]; } circle[++count] = stack[top]; find = 1; return; } else { pre_dfs_1(v, u); stack[--top], vis[v] = 0; } } } /* 找距离 */ bool first = 1; inline void pre_dfs_2(int u, int fa, double w) { if (u == st &amp;&amp; !first) { dis[T(u)][T(fa)] = dis[T(fa)][T(u)] = w; return; } first = 0; for (int i = head[u];i;i = sak[i].nxt) { int v = sak[i].to; double s = sak[i].w; if (v == fa || !vis[v]) continue; dis[T(u)][T(v)] = dis[T(v)][T(u)] = s; pre_dfs_2(v, u, s); } } /* douwn */ inline void dfs(int u, int fa) { for (int i = head[u];i;i = sak[i].nxt) { int v = sak[i].to; double w = sak[i].w; if (v == fa || vis[v]) continue; dfs(v, u); son[u] ++; f[u] += (1.0 * f[v] + w); } if (son[u]) f[u] /= son[u]; } /* up */ inline void re_dfs(int u, int fa, double w) { g[u] = w; if(fat[fa] + son[fa] &gt; 1) g[u] += (fat[fa] * g[fa] + son[fa] * f[fa] - f[u] - w) / (fat[fa] + son[fa] - 1); for (int i = head[u];i;i = sak[i].nxt) { int v = sak[i].to; double w = sak[i].w; if (v == fa || vis[v]) continue; re_dfs(v, u, w); } } /* m = n-1 */ inline void dfs_tree(int u, int fa) { for (int i = head[u];i;i = sak[i].nxt) { int v = sak[i].to; double w = sak[i].w; if (v == fa) continue; if (u != st) g[v] = w + (f[u] * son[u] - w - f[v] + g[u]) / son[u]; else { if (son[u] == 1) { g[v] = w; } else { g[v] = w + (f[u] * son[u] - w - f[v] + g[u]) / (son[u] - 1); } } dfs_tree(v, u); } } int n, m; int main(){ n = read(), m = read(); for (Re int i = 1;i &lt;= m; ++i) { int x = read(), y = read(), z = read(); add(x, y, z), add(y, x, z); } if (m != n) { /* 树的情况比较好转移 */ st = 1; dfs(st, 0); dfs_tree(st, 0); for (int i = 1;i &lt;= n; ++i) { if (i == st) { res += (f[i] * son[i] + g[i]) / son[i]; } else { res += (f[i] * son[i] + g[i]) / (son[i] + 1); } } printf(&quot;%.5lf&quot;, res / (1.0 * n)); return 0; } else { /* 找环 */ pre_dfs_1(1, 0); /* 标记 &amp; 映射 */ memset(vis, 0, sizeof (vis)); for (Re int i = 1;i &lt;= count; ++i) vis[circle[i]] = 1, tag[circle[i]] = i; /* 找距离 */ st = circle[1]; pre_dfs_2(circle[1], 0, 0); /* 对于每个环上的点down下去 */ for (Re int i = 1;i &lt;= count; ++i) dfs(circle[i], 0); for (int i = 1;i &lt;= n; ++i) { if (vis[i]) { fat[i] = 2.0; //在环上父亲数为 2 } else { fat[i] = 1.0; //不在环上父亲数为 1 } } /* 处理信息 */ for (int i = 1;i &lt;= count; ++i) { nex[circle[i]] = circle[i + 1]; pre[circle[i]] = circle[i - 1]; } pre[circle[1]] = circle[count]; nex[circle[count]] = circle[1]; /* 更新环上的g[x] */ for (Re int i = 1;i &lt;= count; ++i) { int nows = C(i); /* 正序来一遍 */ P = 1.0; for (Re int j = nex[nows];j != nows; j = nex[j]) { double w = dis[tag[pre[j]]][tag[j]]; if (nex[j] == nows) g[nows] += P * (w + f[j]); else g[nows] += P * (w + f[j] * son[j] / (son[j] + 1)); P /= (son[j] + 1); } /* 逆序来一遍 */ P = 1.0; for (Re int j = pre[nows];j != nows; j = pre[j]) { double w = dis[tag[nex[j]]][tag[j]]; if (pre[j] == nows) g[nows] += P * (w + f[j]); else g[nows] += P * (w + f[j] * son[j] / (son[j] + 1)); P /= (son[j] + 1); } /* 除 2 */ g[nows] /= 2.0; } /* 更新非环节点g[x] */ for (int i = 1;i &lt;= count; ++i) { for (int j = head[C(i)];j;j = sak[j].nxt) { if (!vis[sak[j].to]) re_dfs(sak[j].to, circle[i], sak[j].w); } } /* 统计答案 */ for (int i = 1;i &lt;= n; ++i) res += ((g[i] * fat[i]) + f[i] * son[i]) / (fat[i] + son[i]); printf(&quot;%.5lf&quot;, res / (1.0 * n)); return 0; } } 一点小总结概率$DP$怎么说呢，真的还是以推$DP$式子为主，但其中有些和其它$DP$不一样，比如，概率作为状态时一般是反着来的，还有就是当一个状态的概率不好表示时，想想去表示它相反的概率，抑或者用容斥原理把概率给硬搞出来，期望同理。 还有就是在$OI$的运用中，大多数题目都是离散型变量，很少连续型的，注意一下它俩的区别。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"/tags/动态规划/"},{"name":"概率问题","slug":"概率问题","permalink":"/tags/概率问题/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"矩阵优化DP类问题应用向小结","slug":"矩阵优化DP类问题应用向小结","date":"2019-09-26T03:50:07.000Z","updated":"2020-02-23T13:38:24.899Z","comments":true,"path":"矩阵优化DP类问题应用向小结/","link":"","permalink":"/矩阵优化DP类问题应用向小结/","excerpt":"","text":"前言本篇强调应用，矩阵的基本知识有所省略。也许会写篇基础向。。。 思想及原理为什么Oier们能够想到用矩阵来加速DP呢？做了一些DP题之后，我们会发现，有时候DP两两状态之间的转移是定向的，也就是说，在DP转移的所有阶段中，对于一个固定的状态$f_i$，它只能转移到一个不变的状态集合${F_i}$中，我们转移的方向不会因为阶段的改变而改变。 好，提炼关键信息，我们需要状态的转移，且状态转移的方式不变（不排除某些毒瘤题），并且对于大多数转移，无非就是各个状态之间的带系数运算。当需要转移的次数过多并且状态数较小时，我们就可以考虑用矩阵快速幂来优化转移。 矩阵快速幂的原理及实现就当前置芝士了吧，略略略~ 当然，如果你需要用矩阵来优化DP，首先你还是得先推出朴素的DP式子，然后观察DP式子各个状态之间的关系，然后构造一个符合状态转移的矩阵，然后就可以快速幂了。 常用套路 模板化，比如用struct封装matrix；个人倾向于把构造的转移矩阵放左边XD。 猜想矩阵加速，对着数据范围YY应该是每个oier都应有的能力。。。 自定义矩阵乘法，我们需要知道对于特定的状态转移，只要它满足广义矩阵乘法的基本性质，我们同样可以用矩阵来加速，下面有道例题就是这样。 预处理掉不合法的转移，蒟蒻做的矩阵优化题有一半都与状压有关，，，那么我们就可以预处理出哪些状态本身就不合法，然后减少矩阵中的元素（一个矩阵就是$O(n^3)$啊）。 设辅助数组来构造转移矩阵，CSP应该不会考到这种难度吧，，，反正知道有这种毒瘤题就对了。 对题目的特殊要求特殊处理，其实也不算特殊处理吧，就是如何把题目中的所有条件都设计进矩阵里面，做到不重不漏。 想到我再补充。。。 例题牛继电器Cow Relays给出一张无向连通图，求S到E经过k条边的最短路。 如果你对Floyd算法理解够深的话，这道题那就是很裸的矩阵优化了，但是需要我们重新定义矩阵乘法，而且必须证明符合广义矩阵乘法的所有性质。 可乐题意略。 有点难度。 难就难在我们如何合理地把题目中的条件设计进矩阵中。 棋盘题意略。 跟状压有关，减去冗余状态，然后矩阵优化转移。 花园题意略。 和上一题一样，但状态表示的难度大一点。 这道题做的时候想到了之前动物园的做法，因为状态之间的转移是连续的，并且很短，自然想到状压，并且每个状态能够转移到的状态也是确定了的，所有想到矩阵加速转移。 所以首先预处理所有合法的转移情况，然后直接上矩阵快速幂，解决。 代码请参看我的blog。 GXOI/GZOI2019 逼死强迫症题目大意：在$2\\times N$的方格中用$N-1$块$2\\times 1$的方砖和$2$块$1\\times 1$的方砖填充，且两块$1\\times 1$的方块不能有相邻的边，求合法方案数。 不得不说，这题真的烦，需要推一大波式子。。。 这道题就需要我们考虑用辅助数组来帮助我们把状态转移设计进矩阵里面。 或许在这里阅读有更好的体验？ 啊，一道计数问题，我开始是这样想的。 如果没有那两块很碍事的砖，我们很容易想到$f[i]=f[i-1]+f[i-2]$，递推走起。 好，现在来看那两块碍事的砖。 首先，我们会发现，这两块特别的砖会把整个方格分成三个部分，我们假设左右两部分刚好是完整的（即是个矩形），那么中间的块就有性质了。 仔细推一推就会发现，当这两个特殊的块间隔奇数个块时，这两个块必定在相异的两行，并且中间只有一种方案构成。 同样的，当这两个特殊的块间隔偶数个块时，这两个块必定在相同的一行，并且中间也只有一种方案构成。 又因为不能有相邻的边，于是计算公式就出来了。$$ans = 2 \\sum_{i=0}^{n-3}\\sum_{j=0}^{i}f[j]f[i-j]$$细细理解下。 用这个大概只能得$20pt$，我们想想怎么优化？看到$N\\le 2e+9$的数据范围，当然要往矩阵快速幂上面想咯。 好，我不会了。 矩阵的推法各有不同吧，我们来一步一步来拆这个式子。 设$g(i)=\\sum_{j=0}^{i}f(j)*f(i-j)$。 所以 $\\begin{equation}\\begin{aligned}g(i)&amp;=\\sum_{j=0}^{i}f(j)f(i-j) \\&amp;=\\sum_{j=0}^{i-2}f(j)f(i-j)+f(i-1)f(1)+f(i)f(0)\\&amp;=\\sum_{j=0}^{i-2}f(j)*[f(i-1-j)+f(i-2-j)]+f(i-1)+f(i)\\&amp;=g(i-2)+g(i-1)+f(i)\\end{aligned}\\end{equation}$ 又设$sum(i)=\\sum_{j=0}^{i}g(j)$ 所以 $\\begin{equation}\\begin{aligned}sum(i)&amp;=\\sum_{j=0}^{i}g(j) \\&amp;=\\sum_{j=0}^{i-1}g(j)+g(i) \\&amp;=sum(i-1)+g(i-2)+g(i-1)+f(i)\\end{aligned}\\end{equation}$ 所以易推得矩阵转移方程： $\\begin{equation}{\\left[ \\begin{array}{ccc}1 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\\\end{array}\\right ]}\\times {\\left[ \\begin{array}{ccc}f(i) \\f(i-1) \\g(i) \\g(i-1) \\sum(i) \\\\end{array}\\right ]}={\\left[ \\begin{array}{ccc}f(i+1)\\f(i)\\g(i+1)\\g(i)\\sum(i+1)\\end{array}\\right ]}\\end{equation}$ 于是$O(125logn)$可过。 注意下界处理。 代码： #include&lt;ctime&gt; #include&lt;queue&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #define ll long long using namespace std; const int MAX = 100000 + 5; const int mod = 1e9 + 7; inline int read(){ int f = 1, x = 0;char ch; do { ch = getchar(); if (ch == &#39;-&#39;) f = -1; } while (ch &lt; &#39;0&#39;||ch&gt;&#39;9&#39;); do {x = x*10+ch-&#39;0&#39;; ch = getchar(); } while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;); return f*x; } struct sakura { ll mar[5][5]; }A; int t, n; inline sakura mul(sakura A, sakura B) { sakura C; memset(C.mar, 0, sizeof (C.mar)); for (int i = 0;i &lt;= 4; ++i) { for (int k = 0;k &lt;= 4; ++k) { for (int j = 0;j &lt;= 4; ++j) { C.mar[i][j] = (C.mar[i][j] + (A.mar[i][k] * B.mar[k][j]) % mod ) % mod; } } } return C; } inline sakura mi(sakura A, int c) { sakura B; B.mar[0][0] = 1, B.mar[1][0] = 1, B.mar[2][0] = 2, B.mar[3][0] = 1, B.mar[4][0] = 3; for (;c;c &gt;&gt;= 1) { if (c &amp; 1) B = mul(A, B); A = mul(A, A); } return B; } int main(){ t = read(); while (t--) { n = read(); if (n &lt; 3) { printf(&quot;0\\n&quot;); continue; } if (n == 3) { printf(&quot;2\\n&quot;); continue; } A.mar[0][0] = 1, A.mar[0][1] = 1, A.mar[0][2] = 0, A.mar[0][3] = 0, A.mar[0][4] = 0; A.mar[1][0] = 1, A.mar[1][1] = 0, A.mar[1][2] = 0, A.mar[1][3] = 0, A.mar[1][4] = 0; A.mar[2][0] = 1, A.mar[2][1] = 1, A.mar[2][2] = 1, A.mar[2][3] = 1, A.mar[2][4] = 0; A.mar[3][0] = 0, A.mar[3][1] = 0, A.mar[3][2] = 1, A.mar[3][3] = 0, A.mar[3][4] = 0; A.mar[4][0] = 1, A.mar[4][1] = 1, A.mar[4][2] = 1, A.mar[4][3] = 1, A.mar[4][4] = 1; sakura ans = mi(A, n - 4); ans.mar[4][0] &lt;&lt;= 1; ans.mar[4][0] %= mod; printf(&quot;%d\\n&quot;, ans.mar[4][0]); } return 0; } 扩展阅读 矩阵十大经典题目，这里面的东西很多。 yyb的分类，跟着神犇刷题总没错，只是有些题太难了啊。。。。 百度百科矩阵乘法，补充基础知识。 线性代数的几何实质，众所周知，矩阵的可以看做是一个向量的集合，这篇文章涉及到了矩阵及其运算的几何意义，而且写得浅显易懂，有兴趣的可以去看看，加深对矩阵变换的理解。 线性代数的几何实质，上面的视频版。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"/tags/动态规划/"},{"name":"矩阵","slug":"矩阵","permalink":"/tags/矩阵/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"more about myself","slug":"about-myself","date":"0999-12-31T15:55:01.000Z","updated":"2020-02-23T14:05:37.651Z","comments":true,"path":"about-myself/","link":"","permalink":"/about-myself/","excerpt":"","text":"欢迎来到更详细的自我介绍~ 本人现高二退役OIer一枚。喜欢二次元，数学，音乐（古典乐赛高！），不推GAL，常以SilentEAG或者是Silent_E的名字在各大OJ鬼混（其他网站应该也有吧，比如某乎）。开这个博客原本的目的是写点东西留着复习时候用的，当然，还可以用来跟dalao们交流。同样欢迎校友来访啊~也许有时会写点不务正业的东西呢。。。 本Blog搭建于Github，还处于初期状态，访问速度比较乌龟并且博主曾经的一些文章还未搬运过来。。。。若对速度忍受不了的话，本人还有一个在cnBlog上的博客建议食用~ 本人QQ：1223610721​，Q我的同学记得留下备注，来互(hu)挂(xiang)友(shang)链(hai)啊~","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"杂文","slug":"杂文","permalink":"/tags/杂文/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]}]}