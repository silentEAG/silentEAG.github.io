{"meta":{"title":"Silent_Eの桜荘","subtitle":null,"description":"喵帕斯!","author":"Silent_E","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-02-13T17:11:22.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-02-13T17:11:22.000Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-02-13T17:11:22.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-02-13T17:11:22.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-02-13T17:11:22.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-02-13T17:11:22.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-02-13T17:11:22.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-02-13T17:11:22.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-02-13T17:11:22.000Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-02-13T17:11:22.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-02-13T17:11:22.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-02-13T17:11:22.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2020-02-19T05:47:28.953Z","updated":"2020-02-19T07:06:42.481Z","comments":true,"path":"2020/02/19/hello-world/","link":"","permalink":"/2020/02/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. $sakura$ SAKURAQuick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2020-02-13T17:11:22.000Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"test","slug":"让问卷星填写成为自动化","date":"2018-12-12T14:16:01.000Z","updated":"2020-02-19T13:57:36.324Z","comments":true,"path":"2018/12/12/让问卷星填写成为自动化/","link":"","permalink":"/2018/12/12/让问卷星填写成为自动化/","excerpt":"","text":"�������þ�û�������ޣ������� ���SC-MY������Ϊ�˸��õ�Ϊ����������ʾ�����Ū�˸��ʾ��������ʩȷʵͦ�����ģ��� ���ܶ�ʱ��������Ҫ��д������ÿ�춼һ����������ô��û�з��Զ���д��TAT�� �У������Ѿ������~ dalao�� Ȼ���ҾͰ�����ĳ�����Ӧ���ʾ��Ľű�QwQ���Ӵ���ҳ���ύ���ᳬ��2s�������������������� ������ʹ���������ű������ͺ���������� PC�� chrome����������ͺ�ο�ԭ�������� Firefox����������ͺ���� QQ����������ͺ���� ���������������������������ʹ��QAQ ��׿�� Firefox����������ͺ��PC�˲�ࡣ ���飺��PC�������нű��� ʹ������ͺ�ٵ�������½ű�������������붪��ȥ~ // ==UserScript== // @name �ʾ��ǲ��ԡ���֧��input radio checkbox // @version 1.1 // @description ���� // @author ��Ƭ�� // @match https://www.wjx.cn/jq/55370924.aspx // @match https://www.wjx.top/jq/55370924.aspx // @grant none // @require https://code.jquery.com/jquery-3.4.1.min.js // ==/UserScript== /* !First!:ԭ���߲�����QAQ��ԭ�������ӣ�https://www.cnblogs.com/FHC1994/p/11721723.html ,��ֻ���޸���һ����д��������Ӧ�����ʾ������� Second:����˹�� 1.���ű��ĳ����Ǽ򻯴����д�ķ�ʽ����ֹʹ�ô˽ű�Ƶ���ύ�� 2.��ȷ���������ݵ���ʵ�ԣ�Ϊ��Ӯ����ս�����Լ���һ�������� Third:��ȷ��ʳ�÷����� 1.ȷ��������ű���������ͺ��ȷ���У�����������½ű����ѱ��δ���ȫ�����ƽ�ȥ�� 2.����ʾ��д����Ҫ�Զ���д�����ݡ� 3.����ű��� 4.��https://www.wjx.cn/jq/55370924.aspx����ᷢ���������Զ����ϡ� 5.ȷ����Ϣ��������ύ��ť����������ύ��ťҲ���밴���뷭������������TAT�� 6.�ǵ�ÿ��15:00֮ǰ��һ��~ 7.��ʹ���������⻶ӭ�ڲ���������~ https://www.cnblogs.com/silentEAG/p/12307164.html�� -----Changed by SilentE PS:���ű����� https://www.wjx.cn/jq/55370924.aspx �� https://www.wjx.top/jq/55370924.aspx ���Զ����У����赣����˽���ա� */ (function() { &#39;use strict&#39;; var opt, s2; //�¶����ɣ���36.5��36.9֮��������ɡ� var a = &quot;36.&quot; + Math.floor(Math.random()*5 + 5).toString(); //��ȡ��������ڲ���������ȷ�ĸ�ʽ var day = new Date(); day.setTime(day.getTime()); if(String(day.getMonth()).length &lt; 2) s2 = &quot;0&quot; + (day.getMonth() + 1).toString(); else s2 = (day.getMonth() + 1).toString(); var s = day.getFullYear()+&quot;-&quot; + s2 + &quot;-&quot; + day.getDate(); //�Զ������ݣ�����ϵ���ȷ��һ�顣 const info=[ [&quot;���Ҹĳ�����&quot;,/(����)/], [&quot;���Ҹĳ�����֤����&quot;,/(����֤����)/], [&quot;ѧУ&quot;,/(ѧУ����λ������)/,/^������ɽ��ѧ$/],//������øġ��� [&quot;���Ҹĳɰ༶&quot;,/(�꼶�༶)/], [&quot;���Ҹĳɼ�ͥ��ϸסַ&quot;,/(��ͥ��ϸסַ)/], [&quot;���Ҹĳ���ϵ�绰&quot;,/(��ϵ�绰)/], [&quot;��&quot;,/(���������人)/],//������øġ��� [a,/(����ѧ������)/],//������øġ��� [&quot;&quot;,/(������״��)/,/(����)/],//Ĭ�Ͻ��� [&quot;&quot;,/(֢״���)/,/(��֢״)/],//Ĭ����֢״ [&quot;&quot;,/(��ͥ��Ա)/,/(����)/],//Ĭ������ [&quot;&quot;,/(�����Ƿ�ǰ��)/,/(��)/],//Ĭ�Ϸ� [&quot;&quot;,/(�Ƿ�Ӵ�)/,/(��)/],//Ĭ�Ϸ� [s,/(�ʱ��)/],//������øġ��� ]; //����Ķ����Ͳ��ÿ����� const ini={ module:&quot;.div_question&quot;, title:&quot;.div_title_question&quot;, type:{ &quot;input_text&quot;:&quot;.inputtext&quot;, &quot;radio&quot;:&quot;.ulradiocheck&quot;, &quot;checkbox&quot;:&quot;.ulradiocheck&quot; } }; $(document).ready(function(){ let itemNum = 0; $(ini.module).each(function(){ itemNum += 1; let title=$(this).find(ini.title).text(); //�ж���� for(let i=0;i&lt;info.length;i++){//ƥ���û���Ϣ if(info[i][1].test(title)){//ƥ�䵽һ����Ϣ,�жϴ��������,��break�� for(let tp in ini.type){ let dom=$(this).find(ini.type[tp]); if(dom.length&gt;0){ switch(tp){ case &quot;input_text&quot;: $(&quot;#q&quot;+itemNum)[0].value = info[i][0]; //��ֵ break; case &quot;radio&quot;: case &quot;checkbox&quot;: $(this).find(&quot;li&quot;).each(function(){ if(info[i].length&gt;=3&amp;&amp;info[i][2].test($(this).text())){ $(this).find(&quot;a&quot;).click(); } }); break; default:console.log(&quot;ini.type��û��ƥ��&quot;+tp+&quot;�ļ�ֵ&quot;); } break; } } break; } } }); /*ȥ�����д�����ǰ���//����ʵ���Զ��ύ*/ //$(&#39;.submitbutton&#39;).click(); }); })(); Ȼ�󰴴���ע�������޸ģ�������ɣ� ÿ����ʾ���ַ���ű��Զ���д��ֻ�谴���ύ��~ ����˹��","categories":[{"name":"����","slug":"����","permalink":"/categories/����/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"�ö�","slug":"�o�","permalink":"/tags/�o�/"}],"keywords":[{"name":"����","slug":"����","permalink":"/categories/����/"}]},{"title":"test","slug":"test","date":"2018-12-12T14:16:01.000Z","updated":"2020-02-19T13:11:57.496Z","comments":true,"path":"2018/12/12/test/","link":"","permalink":"/2018/12/12/test/","excerpt":"","text":"资源分享 26 个比较概率大小的问题 数论小白都能看懂的数学期望讲解 概念$PS$：不需要知道太多概念，能拿来用就行了。 定义样本（$\\omega$）：一次随机试验产生的一个结果。样本空间（$\\Omega$）：一个随机试验的所有可能的结果的全体，即$\\Omega=\\{\\omega\\}$。事件（$A$）：某一类结果，即$A\\subset\\Omega$。基本事件（$s$）：各个互斥的事件即为基本事件。 我们借助样本空间S来定义概率。样本空间是基本事件的集合。 概率论公理样本空间$S$的概率分布$Pr\\{\\}$是一个从$S$的事件到实数的映射，它满足以下公理： 非负性：对于任意事件$A$，$Pr\\{A\\}\\geqslant 0$。 正则性：$Pr\\{S\\}=1$。 可列可加性：对于两个互斥事件$A$与$B$，有$Pr\\{A\\cup B\\}=Pr\\{A\\}+Pr\\{B\\}$。更一般地，对于任意有限或无限事件序列$A_1,A_2,…,$若其两两互斥，则有： Pr\\{\\bigcup_iA_i\\}=\\sum Pr\\{A_i\\} 期望 简单理解，期望的意义就是概率的加权平均数。 假设某随机试验$X$共有$n$种互斥的事件可能发生，其中第$i$个事件发生的概率为$P_i$，价值为$X_i$，则这个随机试验的期望是$E(X)=\\sum P_iX_i$。 期望也可以从频率的角度来理解，我们知道如果不断重复某个随机试验，某个事件发生的频率会趋近于其概率，而将发生过所有事件的价值取平均值，这个值就会趋近于这个随机试验的期望。 期望的线性性质 E(X+Y)=E(X)+E(Y)....(1) E(aX)=aE(X)..............(2) E(XY)=E(X)E(Y)..........(3)证明如下 (1)式: \\begin{align} E(X+Y) =& \\sum_{i,j}(X_i+Y_j)P_iQ_j\\\\ =& \\sum_{i, j} X_{i} P_{i} Q_{j}+\\sum_{i, j} Y_{j} P_{i} Q_{j}\\\\ =& \\sum_{i} X_{i} P_{i} \\sum_{j} Q_{j}+\\sum_{j} Y_{j} Q_{j} \\sum_{i} P_{i}\\\\ =& \\sum_{i} X_{i} P_{i}+\\sum_{i} Y_{j} Q_{j}\\\\ =& E(X)+E(Y) \\end{align}(2)式: \\begin{align} E(aX) =& \\sum_iaX_iP_i \\\\ =& a\\sum_iX_iP_i \\\\ =& aE(X) \\end{align}(3)式: \\begin{align} E(XY)=& \\sum_i\\sum_jX_iY_jP_iQ_j \\\\ =&(\\sum_iX_iP_i)(\\sum_jY_jQ_j) \\\\ =&E(X)E(Y) \\end{align}用数学归纳法可推广到多个。 期望DP定义所求结果为某事件的期望的动态规划。 实际上这类动态规划并不是一个新的类型，它都是在原有的动态规划的基础上，将所求的值改成了概率和期望的相关值，换句话说，这类问题的难度其实还是在动态规划的原型上，概率和期望只是表象。 现在大多数期望题就是手动找公式或者$DP$推出即可，只要处理好边界，然后写好方程，就行了。与常规的求解不同，数学期望经常逆向推出，但不全是。它的代码量很短，但思维难度明显较高。 比如数学期望的$f[x]$一般表示到了$x$这一状态还差多少，最后答案是$f[0]$。 总之，该推公式的还是推，该在图上跑的还是在图上跑，只是注意状态的设计。 练手题目入门：过河少见的连续型随机变量题。 最坏情况下，过一条河需要$3L/v$的时间；最好的情况下，过一条河需要$L/v$的时间，又因为船的位置随机，所以过河时间线性分布，于是期望取个平均值$2L/v$就行了。 掷骰子考虑集合中选取一个不同于已选的新数的概率，所以可以设计$DP$方程：$f[i]$表示取了$i$种数后还需取的期望值。 取了$i$种数，当前取的是新数的概率是$\\frac{n-i}{n}$，当前取的是集合中出现过的数的概率是$\\frac{i}{n}$。所以可得到$DP$转移方程$f[i]=\\frac{n-i}{n}f[i+1]+\\frac{i}{n}f[i]+1$。 进一步化简，得$f[i]=f[i+1]+\\frac{n}{n-i}$。 所以$f[0]=\\sum_{i=1}^n\\frac{n}{i}$。 换教室夭寿啦，NOIP考期望啦。 容易对每节课的选择划分阶段，根据期望的线性性质，可以相加得到总期望。 设$f[i][j][0/1]$表示前$i$节课提交了$j$次申请，当前是否申请时的期望最小体力值。那么只会从$i-1$转移过来。 方程见代码。（懒癌晚期。。。） #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;algorithm&gt; #define db double #define Re register const int N = 2000 + 5; const db INF = 1e18; using std :: max; using std :: min; inline int read() { int f = 1, x = 0; char ch; do { ch = getchar(); if (ch == &#39;-&#39;) f = -1; } while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;); do {x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - &#39;0&#39;; ch = getchar(); } while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;); return f * x; } inline void init(), dp(), ouot(); signed main() { init(), dp(), ouot(); } inline void hand_in() { freopen(&quot;classroom.in&quot;, &quot;r&quot;, stdin); freopen(&quot;classroom.out&quot;, &quot;w&quot;, stdout); } int n, m, v, e, c[N], d[N]; db k[N], f[N][N][2], dis[305][305], ans = INF; inline void init() { hand_in(); n = read(), m = read(), v = read(), e = read(); for (Re int i = 1;i &lt;= n; ++i) c[i] = read(); for (Re int i = 1;i &lt;= n; ++i) d[i] = read(); for (Re int i = 1;i &lt;= n; ++i) scanf(&quot;%lf&quot;, k + i); for (Re int i = 1;i &lt;= v; ++i) { for (Re int j = 1;j &lt;= v; ++j) { if (i != j) dis[i][j] = INF; } } for (Re int i = 1, x, y, w;i &lt;= e; ++i) { x = read(), y = read(), w = read(); dis[x][y] = min(dis[x][y], (db)w); dis[y][x] = dis[x][y]; } for (Re int s = 1;s &lt;= v; ++s) { for (Re int i = 1;i &lt;= v; ++i) { for (Re int j = 1;j &lt;= v; ++j) { dis[i][j] = min(dis[i][j], dis[i][s] + dis[s][j]); } } } } inline void dp() { for (Re int i = 0;i &lt;= n; ++i) { for (Re int j = 0;j &lt;= m; ++j) { f[i][j][0] = f[i][j][1] = INF; } } f[1][0][0] = f[1][1][1] = 0; for (Re int i = 2, lim;i &lt;= n; ++i) { lim = min(i, m); f[i][0][0] = f[i - 1][0][0] + dis[c[i - 1]][c[i]]; for (Re int j = 1;j &lt;= lim; ++j) { f[i][j][0] = min(f[i][j][0], f[i - 1][j][0] + dis[c[i - 1]][c[i]]); f[i][j][0] = min(f[i][j][0], f[i - 1][j][1] + k[i - 1] * dis[d[i - 1]][c[i]] + (1.0 - k[i - 1]) * dis[c[i - 1]][c[i]]); f[i][j][1] = min(f[i][j][1], f[i - 1][j - 1][0] + k[i] * dis[c[i - 1]][d[i]] + (1.0 - k[i]) * dis[c[i - 1]][c[i]]); f[i][j][1] = min(f[i][j][1], f[i - 1][j - 1][1] + k[i] * (k[i - 1] * dis[d[i - 1]][d[i]] + (1.0 - k[i - 1]) * dis[c[i - 1]][d[i]]) + (1.0 - k[i]) * (k[i - 1] * dis[d[i - 1]][c[i]] + (1.0 - k[i - 1]) * dis[c[i - 1]][c[i]])); } } } inline void ouot() { for (int i = 0;i &lt;= m; ++i) ans = min(ans, min(f[n][i][0], f[n][i][1])); printf(&quot;%.2lf&quot;, ans); exit(0); } 进阶：亚瑟王思考后，转化成$ans=\\sum dp[i]*d[i]$，其中,$dp[i]$表示第$i$张卡在$r$轮中打出的概率。 考虑如何计算$dp[i]$。 由于每一轮打出一张卡后，该轮结束，所以每张卡在$r$轮中被打出的概率与在它前面有多少张卡被打出有关。 设$f[i][j]$表示在$r$轮中，前$i$张卡被打出了$j$张的概率，在此情况下，第$i+1$张牌在$r$轮中有$(1-p[i+1])^{r-j}$的概率未被打出，再用$1$减去，就得到了打出的概率。所以枚举$k$得到：$dp[i]=\\sum f[i-1][k]*(1-(1-p[i])^{r-k})$。 现在考虑如何计算$f[i][j]$。 递推。当前的第$i$张卡选或不选。选：$f[i][j]+=f[i-1][j-1](1-(1-p[i])^{r-j+1})$。$(j\\neq 0)$不选：$f[i][j]+=f[i-1][j]((1-p[i])^{r-j})$。$(i\\neq j)$ 边界：$f[1][1]=dp[1]=1-(1-p[1])^r$$f[1][0]=(1-p[1])^r$ 本题得到解决。（注意精度！） #include&lt;cmath&gt; #include&lt;ctime&gt; #include&lt;queue&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #define debug() puts(&quot;FBI WARNING!&quot;) #define ll long long using namespace std; const int MAX = 220 + 5; const int P = 1e5 + 7; inline int read(){ int f = 1, x = 0;char ch; do { ch = getchar(); if (ch == &#39;-&#39;) f = -1; } while (ch &lt; &#39;0&#39;||ch&gt;&#39;9&#39;); do {x = x*10+ch-&#39;0&#39;; ch = getchar(); } while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;); return f * x; } int t, n, r; double p[MAX], d[MAX], ans, f[MAX][MAX], dp[MAX], pw[MAX][MAX]; inline double mi(double a, int b) { double res = 1.0; while (b) { if (b &amp; 1) { res *= a; } a *= a; b &gt;&gt;= 1; } return res; } int main(){ t = read(); while (t--) { memset(dp, 0, sizeof (dp)); memset(f, 0, sizeof (f)); ans = 0; n = read(), r = read(); for (int i = 1;i &lt;= n; ++i) scanf(&quot;%lf %lf&quot;, &amp;p[i], &amp;d[i]); f[1][1] = dp[1] = 1.0 - mi(1.0 - p[1], r); f[1][0] = mi(1.0 - p[1], r); for (int i = 2;i &lt;= n; ++i) { for (int j = 0;j &lt;= min(i, r); ++j) { if (j) { f[i][j] += f[i - 1][j - 1] * (1.0 - mi(1.0 - p[i], r - j + 1)); } if (i != j) { f[i][j] += f[i - 1][j] * mi(1.0 - p[i], r - j); } } } for (int i = 2;i &lt;= n; ++i) { for (int k = 0;k &lt;= min(i - 1, r); ++k) { dp[i] += f[i - 1][k] * (1.0 - mi(1.0 - p[i], r - k)); } } for (int i = 1;i &lt;= n; ++i) { ans += dp[i] * d[i]; } printf(&quot;%.10lf\\n&quot;, ans); } return 0; } 概率充电器$WA$了无数遍。。。有一个坑人的小细节。。。 思考后，可转换成$ans=\\sum (1-res[i])$。其中，$res$表示节点$i$未被充电的概率。 强制把这棵树转化为有根树，我们可以发现，对与任意非根节点，它能否被点亮取决于它的子节点以及它的父亲。想到树形$DP$。 我们设$f[i]$，$g[i]$分别表示$i$不被它的子节点点亮的概率，$i$不被它父亲点亮的概率。 所以$res[i]=f[i]\\times g[i]$。 现在思考如何求$f[i]$。 第一遍$dfs$遍历时，直接 $f[i]=(1-p[i])\\times \\prod_{son\\in i}\\lgroup1-(1-f[son]\\times val(i,son))\\rgroup$，无需过多的解释。 由于根节点无父节点，所以$g[root]=1$，即$res[root]=f[root]$现在，思考如何求非根节点的$g[i]$。 做到这里，我先前有个抽风的想法，以为直接可以$g[v]=ans[u]+(1-ans[u])\\times (1-val(u,v))$($v$是$u$的子节点)，当$WA$到怀疑人生时才想到这是错误的。。。想想为什么？ 请注意，$g[i]$的状态定义是：$i$不被它父亲点亮的概率，所以不管子节点鸟事。。。即默认为$v$不带电，所以我们需要把$ans[u]$除去先前乘进$f[i]$中的$v$子树中不带电的概率。 即$P=\\frac{g[u]\\times f[u]}{1-(1-f[v]\\times val(u,v))}$，$g[v]=P+(1-P)\\times (1-val(u,v))$。 本题得到$O(n)$解决。 #include&lt;cmath&gt; #include&lt;ctime&gt; #include&lt;queue&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; const int MAX = 500000 + 5; inline int read(){ int f = 1, x = 0;char ch; do { ch = getchar(); if (ch == &#39;-&#39;) f = -1; } while (ch &lt; &#39;0&#39;||ch&gt;&#39;9&#39;); do {x = x*10+ch-&#39;0&#39;; ch = getchar(); } while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;); return f * x; } int n, m; double p[MAX], ans[MAX], res, f[MAX], g[MAX], h[MAX]; struct sakura { int to, nxt; double p; }sak[MAX &lt;&lt; 1]; int head[MAX], cnt; inline void add(int x, int y, double p) { ++cnt; sak[cnt].to = y, sak[cnt].nxt = head[x], sak[cnt].p = p, head[x] = cnt; } inline void dfs_1(int u, int fa) { f[u] = 1.0 - p[u]; g[u] = 1.0; for (int i = head[u];i;i = sak[i].nxt) { int v = sak[i].to; double ps = sak[i].p; if (v == fa) continue; dfs_1(v, u); // f[u] *= (1.0 - (1.0 - f[v]) * ps); f[u] *= (f[v] + (1.0 - f[v]) * (1.0 - ps)); } } inline void dfs_2(int u, int fa) { for (int i = head[u];i;i = sak[i].nxt) { int v = sak[i].to; double ps = sak[i].p; if (v == fa) continue; double h; if (f[v] + (1.0 - f[v]) * (1.0 - ps)) { h = (g[u] * f[u]) / (f[v] + (1.0 - f[v]) * (1.0 - ps)); } else h = 0.0; g[v] = h + (1.0 - h) * (1.0 - ps); dfs_2(v, u); } } int main(){ n = read(); for (int i = 1;i &lt; n; ++i) { int a = read(), b = read(); double c; scanf(&quot;%lf&quot;, &amp;c); add(a, b, 0.01 * c); add(b, a, 0.01 * c); } for (int i = 1;i &lt;= n; ++i) scanf(&quot;%lf&quot;, &amp;p[i]), p[i] *= 0.01; dfs_1(1, 0); dfs_2(1, 0); g[1] = 1; for (int i = 1;i &lt;= n; ++i) { ans[i] = f[i] * g[i]; } for (int i = 1;i &lt;= n; ++i) res += (1.0 - ans[i]); printf(&quot;%.6lf&quot;, res); return 0; } 奖励关刚拿到这题。 ？？？ $Woc$！怎么做？ 好在看了眼数据范围，，，哦，，，状压套个期望啊。。。 倒着找，就行了。 #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #define Re register using namespace std; const int MAX = 100 + 5; inline int read(){ int f = 1, x = 0;char ch; do { ch = getchar(); if (ch == &#39;-&#39;) f = -1; } while (ch &lt; &#39;0&#39;||ch&gt;&#39;9&#39;); do {x = x*10+ch-&#39;0&#39;; ch = getchar(); } while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;); return f * x; } int k, n, miko[MAX]; double f[MAX][1 &lt;&lt; 15], a[MAX], ans; int main(){ k = read(), n = read(); for (int i = 1;i &lt;= n; ++i) { scanf(&quot;%lf&quot;, &amp;a[i]); int x; while (x = read()) { miko[i] = miko[i] | (1 &lt;&lt; (x - 1)); } } for (int i = k;i &gt;= 1; --i) { for (int j = 0;j &lt; (1 &lt;&lt; n); ++j) { for (int l = 1;l &lt;= n; ++l) { if ((j &amp; miko[l]) == miko[l]) { f[i][j] += max(f[i + 1][j | (1 &lt;&lt; (l - 1))] + a[l], f[i + 1][j]); } else { f[i][j] += f[i + 1][j]; } } f[i][j] /= n; } } printf(&quot;%.6lf\\n&quot;, f[1][0]); } 迷失游乐园马马马？？？ 是树的情况貌似和前面的看脸充电器差不多？？？搞一下。 我们设从一个节点$i$的子节点传上来的期望值为$f[i]$，从父节点传下来的期望值为$g[i]$，令$u$为$v$的父节点，所以可得$f[u]=\\frac{\\sum f[v]+w(u,v)}{son[u]}$，然后以此更新$g[v]$：$g[v]=w(u,v)+\\frac{f[u]\\times son[u]-w(u,v)-f[v]+g[u]}{son[u]-1+1}$。 具体含义就$YY$一下吧，懒癌晚期。。。 $About$ $1h$ $later…$ $have$ $50$ $Pt$ $…$ 好了，现在处理环的情况！ $Another$ $1h$ $later…$ $Woc$！环怎么处理啊！ 偷偷瞟了眼题解，稍微有了点思路。 首先，从基环树环上节点的子节点传上来的更新是一样的，这点没有任何怀疑。主要是$g[i]$的更新。 对于环上的点，我们默认为它们的父亲即为环上与它相邻的两个节点。所以它分别有一半的概率走到与它相邻的两个节点上。 所以，我们强迫它先顺序走一遍，再逆序走一遍，最后两个期望值相加再除以$2$，即可得到$g[x]$。 $g[i]=\\sum P_j\\times (w(j-1,j)+f[j]\\times \\frac{son[j]}{son[j]+1})$ 其中,$P_j$表示为走到环上节点$j$的概率。 然后环上的$g[x]$更新了，就可以对于环上每个节点所形成的子树进行遍历更新了。 $g[v]=w(u,v)+\\frac{fat[u]\\times g[u]+f[u]\\times son[u]-f[v]-w(u,v)}{fat[u]+son[u]-1}$ 其中，$fat[x]$表示$x$父节点的个数。 找环简单说一下，直接开栈记录就行了。 再吐槽一下，这题我改了一下午加一晚上，还是红彤彤的，后来一气之下全员$double$，，，然后，，，它就过了。。。 这题必须代码。 #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #define Re register #define C(x) circle[x] #define T(x) tag[x] const int MAX = 100000 + 5; inline int read(){ int f = 1, x = 0;char ch; do { ch = getchar(); if (ch == &#39;-&#39;) f = -1; } while (ch &lt; &#39;0&#39;||ch&gt;&#39;9&#39;); do {x = x*10+ch-&#39;0&#39;; ch = getchar(); } while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;); return f * x; } struct sakura { int to, nxt, w; }sak[MAX &lt;&lt; 1]; int head[MAX], cnt; double f[MAX], ans, g[MAX], res, son[MAX], P, dis[25][25], fat[MAX]; int stack[MAX], top, vis[MAX], circle[MAX], count, num, st, nex[MAX], pre[MAX], tag[MAX]; bool find = 0; inline void add(int x, int y, int w) { ++cnt; sak[cnt].to = y, sak[cnt].nxt = head[x], sak[cnt].w = w, head[x] = cnt; } /* 找环 */ inline void pre_dfs_1(int u, int fa) { if (find) return; vis[u] = 1, stack[++top] = u; for (int i = head[u];i;i = sak[i].nxt) { int v = sak[i].to; if (v == fa) continue; if (vis[v]) { while (stack[top] != v) { circle[++count] = stack[top--]; } circle[++count] = stack[top]; find = 1; return; } else { pre_dfs_1(v, u); stack[--top], vis[v] = 0; } } } /* 找距离 */ bool first = 1; inline void pre_dfs_2(int u, int fa, double w) { if (u == st &amp;&amp; !first) { dis[T(u)][T(fa)] = dis[T(fa)][T(u)] = w; return; } first = 0; for (int i = head[u];i;i = sak[i].nxt) { int v = sak[i].to; double s = sak[i].w; if (v == fa || !vis[v]) continue; dis[T(u)][T(v)] = dis[T(v)][T(u)] = s; pre_dfs_2(v, u, s); } } /* douwn */ inline void dfs(int u, int fa) { for (int i = head[u];i;i = sak[i].nxt) { int v = sak[i].to; double w = sak[i].w; if (v == fa || vis[v]) continue; dfs(v, u); son[u] ++; f[u] += (1.0 * f[v] + w); } if (son[u]) f[u] /= son[u]; } /* up */ inline void re_dfs(int u, int fa, double w) { g[u] = w; if(fat[fa] + son[fa] &gt; 1) g[u] += (fat[fa] * g[fa] + son[fa] * f[fa] - f[u] - w) / (fat[fa] + son[fa] - 1); for (int i = head[u];i;i = sak[i].nxt) { int v = sak[i].to; double w = sak[i].w; if (v == fa || vis[v]) continue; re_dfs(v, u, w); } } /* m = n-1 */ inline void dfs_tree(int u, int fa) { for (int i = head[u];i;i = sak[i].nxt) { int v = sak[i].to; double w = sak[i].w; if (v == fa) continue; if (u != st) g[v] = w + (f[u] * son[u] - w - f[v] + g[u]) / son[u]; else { if (son[u] == 1) { g[v] = w; } else { g[v] = w + (f[u] * son[u] - w - f[v] + g[u]) / (son[u] - 1); } } dfs_tree(v, u); } } int n, m; int main(){ n = read(), m = read(); for (Re int i = 1;i &lt;= m; ++i) { int x = read(), y = read(), z = read(); add(x, y, z), add(y, x, z); } if (m != n) { /* 树的情况比较好转移 */ st = 1; dfs(st, 0); dfs_tree(st, 0); for (int i = 1;i &lt;= n; ++i) { if (i == st) { res += (f[i] * son[i] + g[i]) / son[i]; } else { res += (f[i] * son[i] + g[i]) / (son[i] + 1); } } printf(&quot;%.5lf&quot;, res / (1.0 * n)); return 0; } else { /* 找环 */ pre_dfs_1(1, 0); /* 标记 &amp; 映射 */ memset(vis, 0, sizeof (vis)); for (Re int i = 1;i &lt;= count; ++i) vis[circle[i]] = 1, tag[circle[i]] = i; /* 找距离 */ st = circle[1]; pre_dfs_2(circle[1], 0, 0); /* 对于每个环上的点down下去 */ for (Re int i = 1;i &lt;= count; ++i) dfs(circle[i], 0); for (int i = 1;i &lt;= n; ++i) { if (vis[i]) { fat[i] = 2.0; //在环上父亲数为 2 } else { fat[i] = 1.0; //不在环上父亲数为 1 } } /* 处理信息 */ for (int i = 1;i &lt;= count; ++i) { nex[circle[i]] = circle[i + 1]; pre[circle[i]] = circle[i - 1]; } pre[circle[1]] = circle[count]; nex[circle[count]] = circle[1]; /* 更新环上的g[x] */ for (Re int i = 1;i &lt;= count; ++i) { int nows = C(i); /* 正序来一遍 */ P = 1.0; for (Re int j = nex[nows];j != nows; j = nex[j]) { double w = dis[tag[pre[j]]][tag[j]]; if (nex[j] == nows) g[nows] += P * (w + f[j]); else g[nows] += P * (w + f[j] * son[j] / (son[j] + 1)); P /= (son[j] + 1); } /* 逆序来一遍 */ P = 1.0; for (Re int j = pre[nows];j != nows; j = pre[j]) { double w = dis[tag[nex[j]]][tag[j]]; if (pre[j] == nows) g[nows] += P * (w + f[j]); else g[nows] += P * (w + f[j] * son[j] / (son[j] + 1)); P /= (son[j] + 1); } /* 除 2 */ g[nows] /= 2.0; } /* 更新非环节点g[x] */ for (int i = 1;i &lt;= count; ++i) { for (int j = head[C(i)];j;j = sak[j].nxt) { if (!vis[sak[j].to]) re_dfs(sak[j].to, circle[i], sak[j].w); } } /* 统计答案 */ for (int i = 1;i &lt;= n; ++i) res += ((g[i] * fat[i]) + f[i] * son[i]) / (fat[i] + son[i]); printf(&quot;%.5lf&quot;, res / (1.0 * n)); return 0; } } 一点小总结概率$DP$怎么说呢，真的还是以推$DP$式子为主，但其中有些和其它$DP$不一样，比如，概率作为状态时一般是反着来的，还有就是当一个状态的概率不好表示时，想想去表示它相反的概率，抑或者用容斥原理把概率给硬搞出来，期望同理。 还有就是在$OI$的运用中，大多数题目都是离散型变量，很少连续型的，注意一下它俩的区别。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}